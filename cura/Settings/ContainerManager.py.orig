# Copyright (c) 2021 Ultimaker B.V.
# Cura is released under the terms of the LGPLv3 or higher.

import os
import urllib.parse
import uuid
from typing import Any, cast, Dict, List, TYPE_CHECKING, Union

from PyQt5.QtCore import QObject, QUrl
from PyQt5.QtWidgets import QMessageBox

from UM.i18n import i18nCatalog
from UM.FlameProfiler import pyqtSlot
from UM.Logger import Logger
from UM.MimeTypeDatabase import MimeTypeDatabase, MimeTypeNotFoundError
from UM.Platform import Platform
from UM.SaveFile import SaveFile
from UM.Settings.ContainerFormatError import ContainerFormatError
from UM.Settings.ContainerRegistry import ContainerRegistry
from UM.Settings.ContainerStack import ContainerStack
from UM.Settings.DefinitionContainer import DefinitionContainer
from UM.Settings.InstanceContainer import InstanceContainer

import cura.CuraApplication
from cura.Machines.ContainerTree import ContainerTree
from cura.Settings.ExtruderStack import ExtruderStack
from cura.Settings.GlobalStack import GlobalStack

if TYPE_CHECKING:
    from cura.CuraApplication import CuraApplication
    from cura.Machines.ContainerNode import ContainerNode
    from cura.Machines.MaterialNode import MaterialNode
    from cura.Machines.QualityChangesGroup import QualityChangesGroup

catalog = i18nCatalog("cura")


class ContainerManager(QObject):
    """Manager class that contains common actions to deal with containers in Cura.

    This is primarily intended as a class to be able to perform certain actions
    from within QML. We want to be able to trigger things like removing a container
    when a certain action happens. This can be done through this class.
    """


    def __init__(self, application: "CuraApplication") -> None:
        if ContainerManager.__instance is not None:
            raise RuntimeError("Try to create singleton '%s' more than once" % self.__class__.__name__)
        ContainerManager.__instance = self
        try:
            super().__init__(parent = application)
        except TypeError:
            super().__init__()

        self._container_name_filters = {}  # type: Dict[str, Dict[str, Any]]

    @pyqtSlot(str, str, result=str)
    def getContainerMetaDataEntry(self, container_id: str, entry_names: str) -> str:
        metadatas = cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry().findContainersMetadata(id = container_id)
        if not metadatas:
            Logger.log("w", "Could not get metadata of container %s because it was not found.", container_id)
            return ""

        entries = entry_names.split("/")
        result = metadatas[0]
        while entries:
            entry = entries.pop(0)
            result = result.get(entry, {})
        if not result:
            return ""
        return str(result)

    @pyqtSlot("QVariant", str, str)
    def setContainerMetaDataEntry(self, container_node: "ContainerNode", entry_name: str, entry_value: str) -> bool:
        """Set a metadata entry of the specified container.

        This will set the specified entry of the container's metadata to the specified
        value. Note that entries containing dictionaries can have their entries changed
        by using "/" as a separator. For example, to change an entry "foo" in a
        dictionary entry "bar", you can specify "bar/foo" as entry name.

        :param container_node: :type{ContainerNode}
        :param entry_name: :type{str} The name of the metadata entry to change.
        :param entry_value: The new value of the entry.

        TODO: This is ONLY used by MaterialView for material containers. Maybe refactor this.
        Update: In order for QML to use objects and sub objects, those (sub) objects must all be QObject. Is that what we want?
        """

        if container_node.container is None:
            Logger.log("w", "Container node {0} doesn't have a container.".format(container_node.container_id))
            return False
        root_material_id = container_node.getMetaDataEntry("base_file", "")
        container_registry = cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry()
        if container_registry.isReadOnly(root_material_id):
            Logger.log("w", "Cannot set metadata of read-only container %s.", root_material_id)
            return False
        root_material_query = container_registry.findContainers(id = root_material_id)
        if not root_material_query:
            Logger.log("w", "Unable to find root material: {root_material}.".format(root_material = root_material_id))
            return False
        root_material = root_material_query[0]

        entries = entry_name.split("/")
        entry_name = entries.pop()

        sub_item_changed = False
        if entries:
            root_name = entries.pop(0)
            root = root_material.getMetaDataEntry(root_name)

            item = root
            for _ in range(len(entries)):
                item = item.get(entries.pop(0), {})

            if entry_name not in item:
                item[entry_name] = None
            if item[entry_name] != entry_value:
                sub_item_changed = True
            item[entry_name] = entry_value

            entry_name = root_name
            entry_value = root

        root_material.setMetaDataEntry(entry_name, entry_value)
        if sub_item_changed: #If it was only a sub-item that has changed then the setMetaDataEntry won't correctly notice that something changed, and we must manually signal that the metadata changed.
            root_material.metaDataChanged.emit(root_material)

        cura.CuraApplication.CuraApplication.getInstance().getMachineManager().updateUponMaterialMetadataChange()
        return True

    @pyqtSlot(str, result = str)
    def makeUniqueName(self, original_name: str) -> str:
        return cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry().uniqueName(original_name)

    @pyqtSlot(str, result = "QStringList")
    def getContainerNameFilters(self, type_name: str) -> List[str]:
        """Get a list of string that can be used as name filters for a Qt File Dialog

        This will go through the list of available container types and generate a list of strings
        out of that. The strings are formatted as "description (*.extension)" and can be directly
        passed to a nameFilters property of a Qt File Dialog.

        :param type_name: Which types of containers to list. These types correspond to the "type"
            key of the plugin metadata.

        :return: A string list with name filters.
        """

        if not self._container_name_filters:
            self._updateContainerNameFilters()

        filters = []
        for filter_string, entry in self._container_name_filters.items():
            if not type_name or entry["type"] == type_name:
                filters.append(filter_string)

        filters.append("All Files (*)")
        return filters

    @pyqtSlot(str, str, QUrl, result = "QVariantMap")
    def exportContainer(self, container_id: str, file_type: str, file_url_or_string: Union[QUrl, str]) -> Dict[str, str]:
        """Export a container to a file

        :param container_id: The ID of the container to export
        :param file_type: The type of file to save as. Should be in the form of "description (*.extension, *.ext)"
        :param file_url_or_string: The URL where to save the file.

        :return: A dictionary containing a key "status" with a status code and a key "message" with a message
        explaining the status. The status code can be one of "error", "cancelled", "success"
        """

        if not container_id or not file_type or not file_url_or_string:
            return {"status": "error", "message": "Invalid arguments"}

        if isinstance(file_url_or_string, QUrl):
            file_url = file_url_or_string.toLocalFile()
        else:
            file_url = file_url_or_string

        if not file_url:
            return {"status": "error", "message": "Invalid path"}

        if file_type not in self._container_name_filters:
            try:
                mime_type = MimeTypeDatabase.getMimeTypeForFile(file_url)
            except MimeTypeNotFoundError:
                return {"status": "error", "message": "Unknown File Type"}
        else:
            mime_type = self._container_name_filters[file_type]["mime"]

        containers = cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry().findContainers(id = container_id)
        if not containers:
            return {"status": "error", "message": "Container not found"}
        container = containers[0]

        if Platform.isOSX() and "." in file_url:
            file_url = file_url[:file_url.rfind(".")]

        for suffix in mime_type.suffixes:
            if file_url.endswith(suffix):
                break
        else:
            file_url += "." + mime_type.preferredSuffix

        if not Platform.isWindows():
            if os.path.exists(file_url):
                result = QMessageBox.question(None, catalog.i18nc("@title:window", "File Already Exists"),
                                              catalog.i18nc("@label Don't translate the XML tag <filename>!", "The file <filename>{0}</filename> already exists. Are you sure you want to overwrite it?").format(file_url))
                if result == QMessageBox.No:
                    return {"status": "cancelled", "message": "User cancelled"}

        try:
            contents = container.serialize()
        except NotImplementedError:
            return {"status": "error", "message": "Unable to serialize container"}

        if contents is None:
            return {"status": "error", "message": "Serialization returned None. Unable to write to file"}

        try:
            with SaveFile(file_url, "w") as f:
                f.write(contents)
        except OSError:
            return {"status": "error", "message": "Unable to write to this location.", "path": file_url}

        Logger.info("Successfully exported container to {path}".format(path = file_url))
        return {"status": "success", "message": "Successfully exported container", "path": file_url}

    @pyqtSlot(QUrl, result = "QVariantMap")
    def importMaterialContainer(self, file_url_or_string: Union[QUrl, str]) -> Dict[str, str]:
        """Imports a profile from a file

        :param file_url: A URL that points to the file to import.

        :return: :type{Dict} dict with a 'status' key containing the string 'success' or 'error', and a 'message' key
            containing a message for the user
        """

        if not file_url_or_string:
            return {"status": "error", "message": "Invalid path"}

        if isinstance(file_url_or_string, QUrl):
            file_url = file_url_or_string.toLocalFile()
        else:
            file_url = file_url_or_string
        Logger.info(f"Importing material from {file_url}")

        if not file_url or not os.path.exists(file_url):
            return {"status": "error", "message": "Invalid path"}

        try:
            mime_type = MimeTypeDatabase.getMimeTypeForFile(file_url)
        except MimeTypeNotFoundError:
            return {"status": "error", "message": "Could not determine mime type of file"}

        container_registry = cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry()
        container_type = container_registry.getContainerForMimeType(mime_type)
        if not container_type:
            return {"status": "error", "message": "Could not find a container to handle the specified file."}
        if not issubclass(container_type, InstanceContainer):
            return {"status": "error", "message": "This is not a material container, but another type of file."}

        container_id = urllib.parse.unquote_plus(mime_type.stripExtension(os.path.basename(file_url)))
        container_id = container_registry.uniqueName(container_id)

        container = container_type(container_id)

        try:
            with open(file_url, "rt", encoding = "utf-8") as f:
                container.deserialize(f.read(), file_url)
        except PermissionError:
            return {"status": "error", "message": "Permission denied when trying to read the file."}
        except ContainerFormatError:
            return {"status": "error", "Message": "The material file appears to be corrupt."}
        except Exception as ex:
            return {"status": "error", "message": str(ex)}

<<<<<<< HEAD
        container.setName(container_id)
        if container.getMetaDataEntry("type") == "material" and container.getMetaDataEntry("material") == "Custom":
            container.setDirty(True)
            global_stack = Application.getInstance().getGlobalContainerStack()
            machine_materials = global_stack.getMetaDataEntry("has_machine_materials", False)
            if machine_materials:
                new_quality = InstanceContainer("%s_default_%s" % (container.getId(), global_stack.getBottom().getId()))
                metadata = {
                    "material": container.getId()+"_"+global_stack.getBottom().getId(),
                    "quality_type": "custom",
                    "setting_version": 4,
                    "type": "quality",
                    "container_type": type(new_quality)
                }
                new_quality.setMetaData(metadata)
                new_quality.setDefinition(global_stack.getBottom().getId())
                new_quality.setName("Default")
                self._container_registry.addContainer(new_quality)
=======
        container.setDirty(True)
>>>>>>> 84d9d5bec40c7f7a0220af099f2dc5e437760336

        container_registry.addContainer(container)

        return {"status": "success", "message": "Successfully imported container {0}".format(container.getName())}

    @pyqtSlot(result = bool)
    def updateQualityChanges(self) -> bool:
        """Update the current active quality changes container with the settings from the user container.

        This will go through the active global stack and all active extruder stacks and merge the changes from the user
        container into the quality_changes container. After that, the user container is cleared.

        :return: :type{bool} True if successful, False if not.
        """

        application = cura.CuraApplication.CuraApplication.getInstance()
        global_stack = application.getMachineManager().activeMachine
        if not global_stack:
            return False

        application.getMachineManager().blurSettings.emit()

<<<<<<< HEAD
        stacks = []
        s = ExtruderManager.getInstance().getActiveExtruderStack()
        if s is not None:
            stacks.append(s)
            
        for stack in stacks:
            # Find the quality_changes container for this stack and merge the contents of the top container into it.
            quality_changes = stack.qualityChanges
            if not quality_changes or self._container_registry.isReadOnly(quality_changes.getId()):
                Logger.log("e", "Could not update quality of a nonexistant or read only quality profile in stack %s", stack.getId())
                return False
=======
        current_quality_changes_name = global_stack.qualityChanges.getName()
        current_quality_type = global_stack.quality.getMetaDataEntry("quality_type")
        extruder_stacks = global_stack.extruderList
        container_registry = cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry()
        machine_definition_id = ContainerTree.getInstance().machines[global_stack.definition.getId()].quality_definition
        for stack in [global_stack] + extruder_stacks:
            # Find the quality_changes container for this stack and merge the contents of the top container into it.
            quality_changes = stack.qualityChanges

            if quality_changes.getId() == "empty_quality_changes":
                quality_changes = InstanceContainer(container_registry.uniqueName((stack.getId() + "_" + current_quality_changes_name).lower().replace(" ", "_")))
                quality_changes.setName(current_quality_changes_name)
                quality_changes.setMetaDataEntry("type", "quality_changes")
                quality_changes.setMetaDataEntry("quality_type", current_quality_type)
                if stack.getMetaDataEntry("position") is not None:  # Extruder stacks.
                    quality_changes.setMetaDataEntry("position", stack.getMetaDataEntry("position"))
                    quality_changes.setMetaDataEntry("intent_category", stack.quality.getMetaDataEntry("intent_category", "default"))
                quality_changes.setMetaDataEntry("setting_version", application.SettingVersion)
                quality_changes.setDefinition(machine_definition_id)
                container_registry.addContainer(quality_changes)
                stack.qualityChanges = quality_changes

            if not quality_changes or container_registry.isReadOnly(quality_changes.getId()):
                Logger.log("e", "Could not update quality of a nonexistent or read only quality profile in stack %s", stack.getId())
                continue
>>>>>>> 84d9d5bec40c7f7a0220af099f2dc5e437760336

            self._performMerge(quality_changes, stack.getTop())
            self._performMerge(quality_changes, global_stack.getTop())


        cura.CuraApplication.CuraApplication.getInstance().getMachineManager().activeQualityChangesGroupChanged.emit()

        return True

    @pyqtSlot()
    def clearUserContainers(self) -> None:
        """Clear the top-most (user) containers of the active stacks."""

        machine_manager = cura.CuraApplication.CuraApplication.getInstance().getMachineManager()
        machine_manager.blurSettings.emit()

        send_emits_containers = []

        # Go through global and extruder stacks and clear their topmost container (the user settings).
<<<<<<< HEAD
        stack = ExtruderManager.getInstance().getActiveExtruderStack()
        if stack:
            container = stack.getTop()
            container.clear()
            send_emits_containers.append(container)

        for container in send_emits_containers:
            container.sendPostponedEmits()

    ##  Create quality changes containers from the user containers in the active stacks.
    #
    #   This will go through the global and extruder stacks and create quality_changes containers from
    #   the user containers in each stack. These then replace the quality_changes containers in the
    #   stack and clear the user settings.
    #
    #   \return \type{bool} True if the operation was successfully, False if not.
    @pyqtSlot(str, result = bool)
    def createQualityChanges(self, base_name):
        global_stack = Application.getInstance().getGlobalContainerStack()
        if not global_stack:
            return False

        active_quality_name = self._machine_manager.currentQualityName
        if active_quality_name == "":
            Logger.log("w", "No quality container found in stack %s, cannot create profile", global_stack.getId())
            return False

        self._machine_manager.blurSettings.emit()
        if base_name is None or base_name == "":
            base_name = active_quality_name
        unique_name = self._container_registry.uniqueName(base_name)

        # Go through the active stacks and create quality_changes containers from the user containers.
        stacks = [global_stack]
        s = ExtruderManager.getInstance().getActiveExtruderStack()
        if s is not None:
            stacks.append(s)

        new_changes = self._createQualityChanges(s.quality if s is not None else global_stack.quality, unique_name,
                                                 Application.getInstance().getGlobalContainerStack().getBottom(),
                                                 None)
        for stack in stacks:
            user_container = stack.getTop()
            quality_container = stack.quality
            quality_changes_container = stack.qualityChanges
            if not quality_container or not quality_changes_container:
                Logger.log("w", "No quality or quality changes container found in stack %s, ignoring it", stack.getId())
                continue

            self._performMerge(new_changes, quality_changes_container, clear_settings = False)
            self._performMerge(new_changes, user_container)
            stack.replaceContainer(stack.getContainerIndex(quality_changes_container), new_changes)

        self._container_registry.addContainer(new_changes)

        self._machine_manager.activeQualityChanged.emit()
        return True

    ##  Remove all quality changes containers matching a specified name.
    #
    #   This will search for quality_changes containers matching the supplied name and remove them.
    #   Note that if the machine specifies that qualities should be filtered by machine and/or material
    #   only the containers related to the active machine/material are removed.
    #
    #   \param quality_name The name of the quality changes to remove.
    #
    #   \return \type{bool} True if successful, False if not.
    @pyqtSlot(str, result = bool)
    def removeQualityChanges(self, quality_name):
        Logger.log("d", "Attempting to remove the quality change containers with name %s", quality_name)
        containers_found = False

        if not quality_name:
            return containers_found  # Without a name we will never find a container to remove.

        # If the container that is being removed is the currently active quality, set another quality as the active quality
        activate_quality = quality_name == self._machine_manager.activeQualityName
        activate_quality_type = None

        global_stack = Application.getInstance().getGlobalContainerStack()
        if not global_stack or not quality_name:
            return ""
        machine_definition = QualityManager.getInstance().getParentMachineDefinition(global_stack.getBottom())

        for container in QualityManager.getInstance().findQualityChangesByName(quality_name, machine_definition):
            containers_found = True
            if activate_quality and not activate_quality_type:
                activate_quality_type = container.getMetaDataEntry("quality")
            self._container_registry.removeContainer(container.getId())

        if not containers_found:
            Logger.log("d", "Unable to remove quality containers, as we did not find any by the name of %s", quality_name)

        elif activate_quality:
            definition_id = "fdmprinter" if not self._machine_manager.filterQualityByMachine else self._machine_manager.activeDefinitionId
            containers = self._container_registry.findInstanceContainersMetadata(type = "quality", definition = definition_id, quality_type = activate_quality_type)
            if containers:
                self._machine_manager.setActiveQuality(containers[0]["id"])
                self._machine_manager.activeQualityChanged.emit()

        return containers_found

    ##  Rename a set of quality changes containers.
    #
    #   This will search for quality_changes containers matching the supplied name and rename them.
    #   Note that if the machine specifies that qualities should be filtered by machine and/or material
    #   only the containers related to the active machine/material are renamed.
    #
    #   \param quality_name The name of the quality changes containers to rename.
    #   \param new_name The new name of the quality changes.
    #
    #   \return True if successful, False if not.
    @pyqtSlot(str, str, result = bool)
    def renameQualityChanges(self, quality_name, new_name):
        Logger.log("d", "User requested QualityChanges container rename of %s to %s", quality_name, new_name)
        if not quality_name or not new_name:
            return False

        if quality_name == new_name:
            Logger.log("w", "Unable to rename %s to %s, because they are the same.", quality_name, new_name)
            return True

        global_stack = Application.getInstance().getGlobalContainerStack()
        if not global_stack:
            return False

        self._machine_manager.blurSettings.emit()

        new_name = self._container_registry.uniqueName(new_name)

        container_registry = self._container_registry
=======
        global_stack = machine_manager.activeMachine
        for stack in [global_stack] + global_stack.extruderList:
            container = stack.userChanges
            container.clear()
            send_emits_containers.append(container)

        # user changes are possibly added to make the current setup match the current enabled extruders
        machine_manager.correctExtruderSettings()
>>>>>>> 84d9d5bec40c7f7a0220af099f2dc5e437760336

        # The Print Sequence should be changed to match the current setup
        machine_manager.correctPrintSequence()

<<<<<<< HEAD
        for container in containers_to_rename:
            stack_id = global_stack.getId()
            if "extruder" in container:
                stack_id = container["extruder"]
            container_registry.renameContainer(container["id"], new_name, self._createUniqueId(stack_id, new_name))

        if not containers_to_rename:
            Logger.log("e", "Unable to rename %s, because we could not find the profile", quality_name)

        self._machine_manager.activeQualityChanged.emit()
        return True

    ##  Duplicate a specified set of quality or quality_changes containers.
    #
    #   This will search for containers matching the specified name. If the container is a "quality" type container, a new
    #   quality_changes container will be created with the specified quality as base. If the container is a "quality_changes"
    #   container, it is simply duplicated and renamed.
    #
    #   \param quality_name The name of the quality to duplicate.
    #
    #   \return A string containing the name of the duplicated containers, or an empty string if it failed.
    @pyqtSlot(str, str, result = str)
    def duplicateQualityOrQualityChanges(self, quality_name, base_name):
        global_stack = Application.getInstance().getGlobalContainerStack()
        if not global_stack or not quality_name:
            return ""
        machine_definition = global_stack.definition

        active_stacks = ExtruderManager.getInstance().getActiveGlobalAndExtruderStacks()
        if active_stacks is None:
            return ""
        material_metadatas = [stack.material.getMetaData() for stack in active_stacks]

        result = self._duplicateQualityOrQualityChangesForMachineType(quality_name, base_name,
                    QualityManager.getInstance().getParentMachineDefinition(machine_definition),
                    material_metadatas)
        return result[0].getName() if result else ""

    ##  Duplicate a quality or quality changes profile specific to a machine type
    #
    #   \param quality_name The name of the quality or quality changes container to duplicate.
    #   \param base_name The desired name for the new container.
    #   \param machine_definition The machine with the specific machine type.
    #   \param material_metadatas Metadata of materials
    #   \return List of duplicated quality profiles.
    def _duplicateQualityOrQualityChangesForMachineType(self, quality_name: str, base_name: str, machine_definition: DefinitionContainer, material_metadatas: List[Dict[str, Any]]) -> List[InstanceContainer]:
        Logger.log("d", "Attempting to duplicate the quality %s", quality_name)

        if base_name is None:
            base_name = quality_name
        # Try to find a Quality with the name.
        container = QualityManager.getInstance().findQualityByName(quality_name, machine_definition, material_metadatas)
        if container:
            Logger.log("d", "We found a quality to duplicate.")
            return self._duplicateQualityForMachineType(container, base_name, machine_definition)
        Logger.log("d", "We found a quality_changes to duplicate.")
        # Assume it is a quality changes.
        return self._duplicateQualityChangesForMachineType(quality_name, base_name, machine_definition)

    # Duplicate a quality profile
    def _duplicateQualityForMachineType(self, quality_container, base_name, machine_definition) -> List[InstanceContainer]:
        if base_name is None:
            base_name = quality_container.getName()
        new_name = self._container_registry.uniqueName(base_name)

        new_change_instances = []

        # Handle the global stack first.
        global_changes = self._createQualityChanges(quality_container, new_name, machine_definition, None)
        new_change_instances.append(global_changes)
        self._container_registry.addContainer(global_changes)

        # Handle the extruders if present.
        # extruders = machine_definition.getMetaDataEntry("machine_extruder_trains")
        # if extruders:
        #     for extruder_id in extruders:
        #         extruder = extruders[extruder_id]
        #         new_changes = self._createQualityChanges(quality_container, new_name, machine_definition, extruder)
        #         new_change_instances.append(new_changes)
        #         self._container_registry.addContainer(new_changes)

        return new_change_instances

    #  Duplicate a quality changes container
    def _duplicateQualityChangesForMachineType(self, quality_changes_name, base_name, machine_definition) -> List[InstanceContainer]:
        new_change_instances = []
        for container in QualityManager.getInstance().findQualityChangesByName(quality_changes_name,
                                                              machine_definition):
            base_id = container.getMetaDataEntry("extruder")
            if not base_id:
                base_id = container.getDefinition().getId()
            new_unique_id = self._createUniqueId(base_id, base_name)
            new_container = container.duplicate(new_unique_id, base_name)
            new_change_instances.append(new_container)
            self._container_registry.addContainer(new_container)

        return new_change_instances

    ##  Create a duplicate of a material, which has the same GUID and base_file metadata
    #
    #   \return \type{str} the id of the newly created container.
    @pyqtSlot(str, result = str)
    def duplicateMaterial(self, material_id: str) -> str:
        global_stack = Application.getInstance().getGlobalContainerStack()
        if not global_stack:
            return ""

        containers = self._container_registry.findInstanceContainers(id=material_id)
        if not containers:
            Logger.log("d", "Unable to duplicate the material with id %s, because it doesn't exist.", material_id)
            return ""

        # Ensure all settings are saved.
        Application.getInstance().saveSettings()

        # Create a new ID & container to hold the data.
        new_id = self._container_registry.uniqueName(material_id)
        container_type = type(containers[0])  # Could be either a XMLMaterialProfile or a InstanceContainer
        duplicated_container = container_type(new_id)

        # Instead of duplicating we load the data from the basefile again.
        # This ensures that the inheritance goes well and all "cut up" subclasses of the xmlMaterial profile
        # are also correctly created.
        with open(containers[0].getPath(), encoding="utf-8") as f:
            duplicated_container.deserialize(f.read())
        duplicated_container.setMetaDataEntry("GUID", str(uuid.uuid4()))
        duplicated_container.setDirty(True)
        duplicated_container.setMetaDataEntry("material", "Custom")
        duplicated_container.setMetaDataEntry("brand", "Custom")

        printer_id = global_stack.getBottom().getId()
        criteria = {"type": "quality", "material": material_id+"_"+printer_id, "definition": printer_id}
        qualities = self._container_registry.findInstanceContainers(**criteria)
        if len(qualities) > 0:
            for q in qualities:
                new_quality = copy.deepcopy(q)
                new_quality.setMetaDataEntry("id", new_quality.id + "_" + new_id)
                new_quality.setMetaDataEntry("material", new_id + "_" + printer_id)
                new_quality.addMetaDataEntry("duplicated", True)
                new_quality.setDirty(True)
                self._container_registry.addContainer(new_quality)

        machine_materials = global_stack.getMetaDataEntry("has_machine_materials", False)
        if machine_materials and len(qualities) == 0:
            new_quality = InstanceContainer("%s_default_%s" % (new_id, printer_id))
            metadata = {
                "material": new_id + "_" + printer_id,
                "quality_type": "custom",
                "setting_version": 4,
                "type": "quality",
                "container_type": type(new_quality)
            }
            new_quality.setMetaData(metadata)
            new_quality.setDefinition(printer_id)
            new_quality.setName("Default")
            self._container_registry.addContainer(new_quality)

        self._container_registry.addContainer(duplicated_container)

        return self._getMaterialContainerIdForActiveMachine(new_id)

    ##  Create a duplicate of a material or it's original entry
    #
    #   \return \type{str} the id of the newly created container.
    @pyqtSlot(str, result = str)
    def duplicateOriginalMaterial(self, material_id):
=======
        for container in send_emits_containers:
            container.sendPostponedEmits()

    @pyqtSlot("QVariant", bool, result = "QStringList")
    def getLinkedMaterials(self, material_node: "MaterialNode", exclude_self: bool = False) -> List[str]:
        """Get a list of materials that have the same GUID as the reference material
>>>>>>> 84d9d5bec40c7f7a0220af099f2dc5e437760336

        :param material_node: The node representing the material for which to get
            the same GUID.
        :param exclude_self: Whether to include the name of the material you provided.
        :return: A list of names of materials with the same GUID.
        """

        same_guid = ContainerRegistry.getInstance().findInstanceContainersMetadata(GUID = material_node.guid)
        if exclude_self:
            return list({meta["name"] for meta in same_guid if meta["base_file"] != material_node.base_file})
        else:
<<<<<<< HEAD
            # there is a base file, so duplicate the original material
            return self.duplicateMaterial(base_file)

    ##  Create a new material by cloning Generic PLA for the current material diameter and setting the GUID to something unqiue
    #
    #   \return \type{str} the id of the newly created container.
    @pyqtSlot(result = str)
    def createMaterial(self) -> str:
        # Ensure all settings are saved.
        Application.getInstance().saveSettings()

        global_stack = Application.getInstance().getGlobalContainerStack()
        if not global_stack:
            return ""

        # Create a new ID & container to hold the data.
        new_id = self._container_registry.uniqueName("custom_material")
        container_type = type(ExtruderManager.getInstance().getActiveExtruderStack().material)  # Always XMLMaterialProfile, since we specifically clone the base_file

        machine_materials = global_stack.getMetaDataEntry("has_machine_materials", False)

        machine = """<machine>
      <machine_identifier product="%s" />
    </machine>""" % global_stack.getBottom().getId()

        base = """<?xml version='1.0' encoding='utf-8'?>
<fdmmaterial version="1.3" xmlns="http://www.ultimaker.com/material">
  <metadata>
    <name>
      <brand>Custom</brand>
      <material>Custom</material>
      <color />
      <label>%s</label>
      <category />
    </name>
    <color_code>#ffffff</color_code>
    <version>1</version>
    <GUID>%s</GUID>
  </metadata>
  <properties>
  </properties>
  <settings>
    %s
  </settings>
</fdmmaterial>""" % (new_id, str(uuid.uuid4()), machine if machine_materials else "")

        new_material = container_type(new_id)
        new_material.deserialize(base)
        new_material.setDirty(True)

        if machine_materials:
            new_quality = InstanceContainer("%s_default_%s" % (new_id, global_stack.getBottom().getId()))
            metadata = {
                "material": new_id+"_"+global_stack.getBottom().getId(),
                "quality_type": "custom",
                "setting_version": 4,
                "type": "quality",
                "container_type": type(new_quality)
            }
            new_quality.setMetaData(metadata)
            new_quality.setDefinition(global_stack.getBottom().getId())
            new_quality.setName("Default")
            self._container_registry.addContainer(new_quality)

        self._container_registry.addContainer(new_material)

        return self._getMaterialContainerIdForActiveMachine(new_id)

    ##  Find the id of a material container based on the new material
    #   Utilty function that is shared between duplicateMaterial and createMaterial
    #
    #   \param base_file \type{str} the id of the created container.
    def _getMaterialContainerIdForActiveMachine(self, base_file):
        global_stack = Application.getInstance().getGlobalContainerStack()
        if not global_stack:
            return base_file

        has_machine_materials = parseBool(global_stack.getMetaDataEntry("has_machine_materials", default = False))
        has_variant_materials = parseBool(global_stack.getMetaDataEntry("has_variant_materials", default = False))
        has_variants = parseBool(global_stack.getMetaDataEntry("has_variants", default = False))
        if has_machine_materials or has_variant_materials:
            if has_variants:
                materials = self._container_registry.findInstanceContainersMetadata(type = "material", base_file = base_file, definition = global_stack.getBottom().getId(), variant = self._machine_manager.activeVariantId)
            else:
                materials = self._container_registry.findInstanceContainersMetadata(type = "material", base_file = base_file, definition = global_stack.getBottom().getId())

            if materials:
                return materials[0]["id"]

            Logger.log("w", "Unable to find a suitable container based on %s for the current machine.", base_file)
            return "" # do not activate a new material if a container can not be found

        return base_file

    ##  Get a list of materials that have the same GUID as the reference material
    #
    #   \param material_id \type{str} the id of the material for which to get the linked materials.
    #   \return \type{list} a list of names of materials with the same GUID
    @pyqtSlot(str, result = "QStringList")
    def getLinkedMaterials(self, material_id: str):
        containers = self._container_registry.findInstanceContainersMetadata(id = material_id)
        if not containers:
            Logger.log("d", "Unable to find materials linked to material with id %s, because it doesn't exist.", material_id)
            return []

        material_container = containers[0]
        material_base_file = material_container.get("base_file", "")
        material_guid = material_container.get("GUID", "")
        if not material_guid:
            Logger.log("d", "Unable to find materials linked to material with id %s, because it doesn't have a GUID.", material_id)
            return []

        containers = self._container_registry.findInstanceContainersMetadata(type = "material", GUID = material_guid)
        linked_material_names = []
        for container in containers:
            if container["id"] in [material_id, material_base_file] or container.get("base_file") != container["id"]:
                continue

            linked_material_names.append(container["name"])
        return linked_material_names

    ##  Unlink a material from all other materials by creating a new GUID
    #   \param material_id \type{str} the id of the material to create a new GUID for.
    @pyqtSlot(str)
    def unlinkMaterial(self, material_id: str):
        containers = self._container_registry.findInstanceContainers(id=material_id)
        if not containers:
            Logger.log("d", "Unable to make the material with id %s unique, because it doesn't exist.", material_id)
            return ""

        containers[0].setMetaDataEntry("GUID", str(uuid.uuid4()))
=======
            return list({meta["name"] for meta in same_guid})
>>>>>>> 84d9d5bec40c7f7a0220af099f2dc5e437760336

    @pyqtSlot("QVariant")
    def unlinkMaterial(self, material_node: "MaterialNode") -> None:
        """Unlink a material from all other materials by creating a new GUID

        :param material_id: :type{str} the id of the material to create a new GUID for.
        """
        # Get the material group
        if material_node.container is None:  # Failed to lazy-load this container.
            return
        root_material_query = cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry().findInstanceContainers(id = material_node.getMetaDataEntry("base_file", ""))
        if not root_material_query:
            Logger.log("w", "Unable to find material group for %s", material_node)
            return
        root_material = root_material_query[0]

        # Generate a new GUID
        new_guid = str(uuid.uuid4())

        # Update the GUID
        # NOTE: We only need to set the root material container because XmlMaterialProfile.setMetaDataEntry() will
        # take care of the derived containers too
        root_material.setMetaDataEntry("GUID", new_guid)

    def _performMerge(self, merge_into: InstanceContainer, merge: InstanceContainer, clear_settings: bool = True) -> None:
        if merge == merge_into:
            return

        for key in merge.getAllKeys():
            merge_into.setProperty(key, "value", merge.getProperty(key, "value"))

        if clear_settings:
            merge.clear()

    def _updateContainerNameFilters(self) -> None:
        self._container_name_filters = {}
        plugin_registry = cura.CuraApplication.CuraApplication.getInstance().getPluginRegistry()
        container_registry = cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry()
        for plugin_id, container_type in container_registry.getContainerTypes():
            # Ignore default container types since those are not plugins
            if container_type in (InstanceContainer, ContainerStack, DefinitionContainer, GlobalStack, ExtruderStack):
                continue

            serialize_type = ""
            try:
                plugin_metadata = plugin_registry.getMetaData(plugin_id)
                if plugin_metadata:
                    serialize_type = plugin_metadata["settings_container"]["type"]
                else:
                    continue
            except KeyError as e:
                continue

            mime_type = container_registry.getMimeTypeForContainer(container_type)
            if mime_type is None:
                continue
            entry = {
                "type": serialize_type,
                "mime": mime_type,
                "container": container_type
            }

            suffix = mime_type.preferredSuffix
            if Platform.isOSX() and "." in suffix:
                # OSX's File dialog is stupid and does not allow selecting files with a . in its name
                suffix = suffix[suffix.index(".") + 1:]

            suffix_list = "*." + suffix
            for suffix in mime_type.suffixes:
                if suffix == mime_type.preferredSuffix:
                    continue

                if Platform.isOSX() and "." in suffix:
                    # OSX's File dialog is stupid and does not allow selecting files with a . in its name
                    suffix = suffix[suffix.index("."):]

                suffix_list += ", *." + suffix

            name_filter = "{0} ({1})".format(mime_type.comment, suffix_list)
            self._container_name_filters[name_filter] = entry

<<<<<<< HEAD
    ##  Creates a unique ID for a container by prefixing the name with the stack ID.
    #
    #   This method creates a unique ID for a container by prefixing it with a specified stack ID.
    #   This is done to ensure we have an easily identified ID for quality changes, which have the
    #   same name across several stacks.
    #
    #   \param stack_id The ID of the stack to prepend.
    #   \param container_name The name of the container that we are creating a unique ID for.
    #
    #   \return Container name prefixed with stack ID, in lower case with spaces replaced by underscores.
    def _createUniqueId(self, stack_id, container_name):
        result = stack_id + "_" + container_name
        result = result.lower()
        result.replace(" ", "_")
        return result

    ##  Create a quality changes container for a specified quality container.
    #
    #   \param quality_container The quality container to create a changes container for.
    #   \param new_name The name of the new quality_changes container.
    #   \param machine_definition The machine definition this quality changes container is specific to.
    #   \param extruder_id
    #
    #   \return A new quality_changes container with the specified container as base.
    def _createQualityChanges(self, quality_container, new_name, machine_definition, extruder_id):
        base_id = machine_definition.getId() if extruder_id is None else extruder_id

        # Create a new quality_changes container for the quality.
        quality_changes = InstanceContainer(self._createUniqueId(base_id, new_name))
        quality_changes.setName(new_name)
        quality_changes.addMetaDataEntry("type", "quality_changes")
        quality_changes.addMetaDataEntry("quality_type", quality_container.getMetaDataEntry("quality_type", "default"))

        # If we are creating a container for an extruder, ensure we add that to the container
        if extruder_id is not None:
            quality_changes.addMetaDataEntry("extruder", extruder_id)

        # If the machine specifies qualities should be filtered, ensure we match the current criteria.
        if not machine_definition.getMetaDataEntry("has_machine_quality"):
            quality_changes.setDefinition("fdmprinter")
        else:
            quality_changes.setDefinition(QualityManager.getInstance().getParentMachineDefinition(machine_definition).getId())

        if machine_definition.getMetaDataEntry("has_machine_materials"):
            metadata = quality_container.getMetaData()
            if "material" in metadata:
                quality_changes.getMetaData()["material"] = metadata["material"]

        from cura.CuraApplication import CuraApplication
        quality_changes.addMetaDataEntry("setting_version", CuraApplication.SettingVersion)
        return quality_changes


    ##  Import profiles from a list of file_urls.
    #   Each QUrl item must end with .curaprofile, or it will not be imported.
    #
    #   \param QVariant<QUrl>, essentially a list with QUrl objects.
    #   \return Dict with keys status, text
    @pyqtSlot("QVariantList", result="QVariantMap")
    def importProfiles(self, file_urls):
        status = "ok"
        results = {"ok": [], "error": []}
        for file_url in file_urls:
            if not file_url.isValid():
                continue
            path = file_url.toLocalFile()
            if not path:
                continue
            if not path.endswith(".curaprofile"):
                continue

            single_result = self._container_registry.importProfile(path)
            if single_result["status"] == "error":
                status = "error"
            results[single_result["status"]].append(single_result["message"])

        return {
            "status": status,
            "message": "\n".join(results["ok"] + results["error"])}
=======
    @pyqtSlot(QUrl, result = "QVariantMap")
    def importProfile(self, file_url: QUrl) -> Dict[str, str]:
        """Import single profile, file_url does not have to end with curaprofile"""
>>>>>>> 84d9d5bec40c7f7a0220af099f2dc5e437760336

        if not file_url.isValid():
            return {"status": "error", "message": catalog.i18nc("@info:status", "Invalid file URL:") + " " + str(file_url)}
        path = file_url.toLocalFile()
        if not path:
            return {"status": "error", "message": catalog.i18nc("@info:status", "Invalid file URL:") + " " + str(file_url)}
        return cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry().importProfile(path)

    @pyqtSlot(QObject, QUrl, str)
    def exportQualityChangesGroup(self, quality_changes_group: "QualityChangesGroup", file_url: QUrl, file_type: str) -> None:
        if not file_url.isValid():
            return
        path = file_url.toLocalFile()
        if not path:
            return

        container_registry = cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry()
        container_list = [cast(InstanceContainer, container_registry.findContainers(id = quality_changes_group.metadata_for_global["id"])[0])]  # type: List[InstanceContainer]
        for metadata in quality_changes_group.metadata_per_extruder.values():
            container_list.append(cast(InstanceContainer, container_registry.findContainers(id = metadata["id"])[0]))
        cura.CuraApplication.CuraApplication.getInstance().getContainerRegistry().exportQualityProfile(container_list, path, file_type)

    __instance = None   # type: ContainerManager

    @classmethod
    def getInstance(cls, *args, **kwargs) -> "ContainerManager":
        return cls.__instance
